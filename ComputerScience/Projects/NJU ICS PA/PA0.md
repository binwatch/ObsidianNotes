# ä¸–ç•Œè¯ç”Ÿçš„å‰å¤œ: å¼€å‘ç¯å¢ƒé…ç½®

## Problems & Solutions

In the [compling NEMU](https://nju-projectn.github.io/ics-pa-gitbook/ics2022/0.6.html#compiling-and-running-nemu) section I found some compile errors when running `make menuconfig`.

Here are some common sense about `make` errors:

- Error messages are all either prefixed with _the name of the program_ (usually `make`), or, if the error is found in a makefile, the name of the file and line number containing the problem.
- make\[\<Integer\>\]: The \<Integer\> shows the deepth of [recursion](http://www.gnu.org/software/make/manual/make.html#Recursion)
- Sometimes `make` errors are not fatal, especially in the presence of a `-` prefix on a recipe line, or the `-k` command line option. **Errors that are fatal are prefixed with the string** `***`

You can found more detail in the [Errors Generated by Make](https://www.gnu.org/software/make/manual/html_node/Error-Messages.html) appendix.

```ad-quote
Make always returns one of _three error codes_, as stated on [gnu.org](http://www.gnu.org/software/make/manual/html_node/Running.html):

- 0: Exit status is 'Successful'
- 2: Make Encountered Errors
- 1: Return response to -q (question) flag, indicating that targets require updating
``` 

It can be tested this by running `make` then running `echo $?` in the terminal to print the previous return code.

Make will print out _other error codes_ it encounters (like the 127 in the problem below), but if it runs into an error it will always return an error code of 2.

````ad-help
**\[Problem 1\]** â“ When running `make menuconfig` for the first time, I get the following output:

```
/home/xyu/Projects/ics2022/nemu/scripts/config.mk:20: Warning: .config does not exists!
/home/xyu/Projects/ics2022/nemu/scripts/config.mk:21: To build the project, first run 'make menuconfig'.
+ YACC build/parser.tab.h
make[1]: bison: No such file or directory
make[1]: *** [Makefile:27: build/parser.tab.h] Error 127
make: *** [/home/xyu/Projects/ics2022/nemu/scripts/config.mk:39: /home/xyu/Projects/ics2022/nemu/tools/kconfig/build/mconf] Error 2
```

**\[Solution 1\]** âœ… Here is a fatal error that _Bison_ cannot be found (Error 127), just install the missing tool:

```shell
sudo apt install bison
```
````

````ad-help
**\[Problem 2\]** â“ Run `make menuconfig` again, I get another similar error:

```
/home/xyu/Projects/ics2022/nemu/scripts/config.mk:20: Warning: .config does not exists!
/home/xyu/Projects/ics2022/nemu/scripts/config.mk:21: To build the project, first run 'make menuconfig'.
+ YACC build/parser.tab.h
+ LEX build/lexer.lex.c
make[1]: flex: No such file or directory
make[1]: *** [Makefile:23: build/lexer.lex.c] Error 127
make: *** [/home/xyu/Projects/ics2022/nemu/scripts/config.mk:39: /home/xyu/Projects/ics2022/nemu/tools/kconfig/build/mconf] Error 2
```

**\[Solution 2\]** âœ… Install the _Flex_ tool:

```shell
sudo apt install flex
```
````

```ad-note
title: **\[Extension\]** â› About Flex and Bison

Linux Flex/Bison evolves from Unix Lex/YACC, they are tools for **building programs that handle structured input**. They were originally tools for **building compilers**(From the user's point of view, Flex and Bison are tools for generating lexers and parsers respectively on Linux), but they have proven to be useful in many other areas.

Here are [O'Reilly Flex & Bison](https://www.oreilly.com/library/view/flex-bison/9780596805418/) book, [GNU Flex](https://github.com/westes/flex) and [GNU Bison](https://www.gnu.org/software/bison/)
``` 

```ad-summary
title: **\[Review\]** ğŸ—¨ Where I was stuck

At first I was just focusing on the Warning from _config.mk_, ignored the following error info totally.

However this Warning info was not the reason why `make` stopped, it just print some hint, do not terminate the program.

To debug and solve problem, figure out what is error info from the output is of first importance.
``` 

## å¿…ç­”é¢˜

- su è®¤è¯å¤±è´¥æ˜¯æ€ä¹ˆå›äº‹? *å‡ºç° su: Authentication failure å¯èƒ½çš„åŸå› ï¼š*
	- *è¾“å…¥äº†é”™è¯¯çš„å¯†ç *
	- *root è´¦æˆ·è¢«ç¦ç”¨ Here is [Why the root account is disabled by default in Ubuntu](https://askubuntu.com/questions/6676/why-is-there-no-option-to-login-as-root)*
- grep æç¤º no such file or directory æ˜¯ä»€ä¹ˆæ„æ€? *ç»™å‡ºçš„æ–‡ä»¶è·¯å¾„ä¸å­˜åœ¨*
- è¯·é—®æ€ä¹ˆå¸è½½ Ubuntu? *STFW. Uninstall Ubuntu safely from Windows dual boot mode basically follow these steps:*
	- *Change the boot order in UEFI settings and give priority to Windows Boot Manager. You may also delete Grub entry from UEFI setting, if your system gives you this option. If that doesnâ€™t work then youâ€™ll have to repair boot with a bootable Windows disk.*
	- *Deleting the Ubuntu partition from Windows.*
- C è¯­è¨€çš„ xxx è¯­æ³•æ˜¯ä»€ä¹ˆæ„æ€? *STFW & RTFM. Please check [C reference](https://en.cppreference.com/w/c)*
- ignoring return vaule of 'scanf' æ˜¯ä»€ä¹ˆæ„æ€? *On success, `scanf` returns the number of items successfully read. ä»£ç ä¸­è°ƒç”¨ `scanf` çš„ä½ç½®æ²¡æœ‰å¯¹è¿”å›å€¼è¿›è¡Œå¤„ç†*
- å‡ºç° curl: not found è¯¥æ€ä¹ˆåŠ? *æ ¹æ®æç¤ºæ‰§è¡Œ `sudo apt install curl`*
- ä¸ºä»€ä¹ˆ strtok è¿”å› NULL? _æ ¹æ® [cppreference](https://en.cppreference.com/w/cpp/string/byte/strtok) çš„è§£é‡Š `strtok( char* str, const char* delim )` å‡½æ•°åœ¨ `str` æŒ‡å‘çš„å­—ç¬¦ä¸²ä¸­æ‰¾åˆ°å¹¶è¿”å›æŒ‡å‘ä¸‹ä¸€ä¸ªåŒ¹é… `delim` çš„ `token` çš„æŒ‡é’ˆï¼Œå¦‚æœæ²¡æœ‰åŒ¹é…çš„ç»“æœï¼Œè¿”å› `nullptr`(åœ¨ C è¯­è¨€ä¸­å¯¹åº” `NULL`)_
- ä¸ºä»€ä¹ˆä¼šæœ‰ Segmentation fault è¿™ä¸ªé”™è¯¯? *According to [Wikipedia](https://en.wikipedia.org/wiki/Segmentation_fault#Overview), A segmentation fault occurs when a program attempts to **access a memory location that it is not allowed to access**, or attempts to **access a memory location in a way that is not allowed** (for example, attempting to write to a read-only location, or to overwrite part of the operating system).*
- ä»€ä¹ˆæ˜¯ busybox? *According to [busybox.net](https://busybox.net/about.html) and [Wikipedia](https://en.wikipedia.org/wiki/BusyBox), BusyBox is a software suite that combines **tiny versions of many common UNIX utilities** into **a single executable file**,. It runs in a variety of POSIX environments such as Linux, Android, and FreeBSD, although many of the tools it provides are designed to work with interfaces provided by the Linux kernel. It was specifically created for **embedded operating systems** with **very limited resources**, provides a fairly complete environment for any small or embedded system. The utilities in BusyBox generally have fewer options than their full-featured GNU cousins; however, the options that are included provide the expected functionality and behave very much like their GNU counterparts.*

## è¯»åæ„Ÿ

> è°ˆè°ˆä½ å¯¹"å¥½çš„æé—®"ä»¥åŠ"é€šè¿‡ STFW å’Œ RTFM ç‹¬ç«‹è§£å†³é—®é¢˜"çš„çœ‹æ³•.

åœ¨é‡åˆ°é—®é¢˜æ—¶ï¼Œåº”è¯¥é¦–å…ˆå°è¯•è‡ªå·±ç‹¬ç«‹è§£å†³ï¼š

- æˆ‘é‡åˆ°çš„é—®é¢˜æ˜¯ä»€ä¹ˆï¼Ÿ
- é‡åˆ°çœ‹ä¸æ‡‚çš„ä¿¡æ¯ï¼Œåº”è¯¥ STFW å’Œ RTFW
- é—®é¢˜çš„å…³é”®åœ¨å“ªé‡Œï¼Ÿå¯ä»¥å¿½ç•¥ä¸€äº›å¤æ‚ä½†æš‚æ—¶ä¸ç›¸å…³çš„ä¿¡æ¯
- æˆ‘å·²ç»æ˜ç™½äº†æˆ‘é‡åˆ°çš„é—®é¢˜ï¼Œå¦‚ä½•è§£å†³ï¼Ÿï¼ˆSTFW/RTFW/RTFSCï¼‰

Web å’Œ manual ä¸­çš„ä¿¡æ¯å¯¹å¾ˆå¤šé—®é¢˜é€šå¸¸å·²ç»è¶³å¤Ÿï¼ŒSTFW å’Œ RTFM ä¸ä»…èƒ½å¤Ÿè§£å†³é—®é¢˜ï¼Œè¿˜å¯ä»¥è®©ä½ å­¦ä¼šç‹¬ç«‹è§£å†³é—®é¢˜çš„æ–¹å¼ï¼Œæé«˜ä¸‹ä¸€æ¬¡è§£å†³é—®é¢˜çš„æ•ˆç‡ã€‚ä¸åšä»»ä½•åŠªåŠ›å°±è¯¢é—®ä»–äººå¯èƒ½èŠ±è´¹å¾ˆé•¿çš„æ—¶é—´ï¼ˆåˆ«äººå¾ˆå¯èƒ½æ²¡æœ‰ç©ºã€ä¹Ÿæ²¡æœ‰ä¹‰åŠ¡å›ç­”ä½ çš„é—®é¢˜ï¼ï¼‰ï¼Œä½†ä»ä¸èƒ½è§£å†³ä½ çš„é—®é¢˜ï¼Œæˆ–è€…è§£å†³äº†ä½ çš„é—®é¢˜ï¼Œä½†ä½ æ²¡æœ‰ä»ä¸­å­¦åˆ°ä»»ä½•æœ‰ç”¨çš„ä¸œè¥¿ï¼Œä¸‹ä¸€æ¬¡é‡åˆ°é—®é¢˜æ—¶ä½ è¿˜è¦æ±‚åŠ©ä»–äººã€‚

æ­£ç¡®çš„ STFW æ–¹å¼åŒæ ·é‡è¦ï¼Œæ¯”å¦‚ä½¿ç”¨ Google ä¸ Wikipedia æœç´¢ä¸€èˆ¬æ€§é—®é¢˜ï¼Œåœ¨ Stackoverflow è®ºå›ä¸Šæœç´¢æŠ€æœ¯é—®é¢˜ç­‰ã€‚å¥½çš„ STFW èƒ½è®©ä½ å¿«é€Ÿæ‰¾åˆ°è§£å†³é—®é¢˜çš„æ–¹æ³•ï¼Œå¹¶èƒ½å¤Ÿä»ä¸­å­¦åˆ°æœ‰ç”¨çš„çŸ¥è¯†ã€‚

å½“ä½ åšäº†å¤§é‡åŠªåŠ›å¹¶ä¸”è®¤çœŸæ€è€ƒè¿‡ä»ç„¶ä¸èƒ½è§£å†³é—®é¢˜ï¼Œå†å‘åˆ«äººæé—®ã€‚

â€œå¥½çš„æé—®â€ åº”è¯¥æ˜¯ï¼š

- ç®€æ´ã€æ¸…æ™°åœ°æè¿°è‡ªå·±çš„æ ¹æœ¬é—®é¢˜æ˜¯ä»€ä¹ˆ
- è‡ªå·±åšäº†å“ªäº›åŠªåŠ›ï¼Œä½†ä»å¾—åˆ°ä»€ä¹ˆç»“æœ
- åˆ—å‡ºé—®é¢˜äº§ç”Ÿçš„ç¯å¢ƒ
- æ ‡å‡ºé‡ç‚¹
- åœ¨æ­£ç¡®çš„åœ°æ–¹ã€å‘æ­£ç¡®çš„äººæé—®
- æ­£ç¡®çš„æé—®æ–¹å¼ä½¿ä½ çš„é—®é¢˜å®¹æ˜“å›å¤
- ä¸è¦æ·»åŠ å¤šä½™çš„å†…å®¹
- æœ‰ç¤¼è²Œ

## è“æ¡†æ€è€ƒé¢˜

### Where is GUI?

> Have you wondered if there is something that you can do it in CLI, but can not in GUI? Have no idea? If you are asked to count how many lines of code you have coded during the ç¨‹åºè®¾è®¡åŸºç¡€ course, what will you do?

Assume all my code during the ç¨‹åºè®¾è®¡åŸºç¡€ course are stored in the _~/Labs/pb_ directory and all my source code files end with _.h_ or _.c_. I can use the following command:

```shell
find ~/Labs/pb -name '*.[ch]' | xargs wc --lines
```

to count how many lines of code I have coded.

That's just what CLI can do while GUI cannot, deal with huge workload using just one line of command. CLI makes work faster and easier.

### Why executing the "poweroff" command requires superuser privilege?

> Can you provide a scene where bad thing will happen if the `poweroff` command does not require superuser privilege?

**GNU/Linux operating systems are multi-user.** When there are some other users are logged into the system, if `poweroff` command works without superuser privilege, one user can easily terminate and damage other users' work, they may still running their programs when you execute `poweroff`.

```ad-seealso
title: **\[More\]** ğŸ›¼
However, I found that I can execute the `poweroff` command without superuser privilege in Ubuntu22.04 LTS. Here is [Why does `reboot` and `poweroff` work without super user privileges in Ubuntu 16.04?](https://askubuntu.com/questions/774740/why-does-reboot-and-poweroff-work-without-super-user-privileges-in-ubuntu-16), it says that Ubuntu 16.04 (so I think it should also works fo 22.04) is "smart" enough to realize when there is in fact another user logged in. If the number of users logged in is more then 1, executing the `poweroff` command still require superuser privilege.
```

### Things behind scrolling

> You should have used scroll bars in GUI. You may take this for granted. So you may consider the original un-scrollable terminal (the one you use when you just log in) the hell. But think of these: why the original terminal can not be scrolled? How does `tmux` make the terminals scrollable? And last, do you know how to implement a scroll bar?
> GUI is not something mysterious. Remember, behind every elements in GUI, there is a story about it. Learn the story, and you will learn a lot. You may say "I just use GUI, and it is unnecessary to learn the story." Yes, you are right. The appearance of GUI is to hide the story for users. But almost everyone uses GUI in the world, and that is why you can not tell the difference between you and them.

From [Wikipedia](https://en.wikipedia.org/wiki/Scrolling), scrolling **does not change the layout** of the text or pictures but **moves the user's view** across what is apparently a larger image that is not wholly seen. Scrolling may take place in **discrete increments** (perhaps one or a few lines of text at a time), or **continuously** (**smooth scrolling**).

Based my observation I think scrolling using keys is take place in discrete increments and using mouse is smooth scrolling.

I guess to implement a scroll bar (or scrolling with keys) needs firstly capture the position of mouse when cliking and the moment it releases, then the vertical movement distance of the cursor (or the key-bind that triggers the scroll). To display the scrolling effect, we also need to store the command executed before in this shell and their output. When scrolling are triggered, compute showing what commands and their output based on the size of this shell, scrolling distance, font size and so on, then display them.

### What happened?

> You should know how a program is generated in the ç¨‹åºè®¾è®¡åŸºç¡€ course. But do you have any idea about what happened when a bunch of information is output to the screen during `make` is executed?

From [how make works](https://www.gnu.org/software/make/manual/html_node/How-Make-Works.html), `make` **reads the makefile in the current directory** and begins by processing the first rule. By default, executing `make` without parameter (you can use it to specify the target) **starts with the first target**, which is `make` strives ultimately to update.

But **before make can fully process this rule, it must process the rules for the files that target depends on**. Each of these files is processed according to its own rule. These rules say to update each â€˜.oâ€™ file by compiling its source file. The recompilation must be done if the source file, or any of the header files named as prerequisites, is more recent than the object file, or if the object file does not exist.

The other rules are processed because their targets appear as prerequisites of the goal. If some other rule is not depended on by the goal (or anything it depends on, etc.), that rule is not processed, unless you tell make to do so (with a command such as make clean).

What `make` do is just execute a seqence of commands in shell from the rules described by the makefile, usually the goal is to compile source files, link object files, and finally get an executable.

